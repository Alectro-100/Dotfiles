#!/usr/bin/env bash

# -----------------------------------------------------------------------------
# @title    MountSSHFS_filesystem
# @desc     A portable SSHFS mounting utility script with network checks,
#           timeout auto-unmounting, and remote config editing via terminal.
# @author   Me
# @version  1.0
# @license  MIT
# @repo     https://github.com/your-username/dotfiles (or wherever you keep it)
# -----------------------------------------------------------------------------

# Operation flags
ENABLE_DEBUG=0    # Override debug config with --debug flag or manual toggle

PROFILE_DIRECTORY='${HOME}/.sshfsProfiles'

### Default Config Template (Do not edit this) ###
declare -A CONFIG=(
    # Remote SSH username
    [USER]=""
    # Remote host (IP or FQDN (Fully Qualified Domain Name))
    [HOST]=""
    # Remote path to mount
    [REMOTE_MOUNT_POINT]=""
    # Local mount point
    [LOCAL_MOUNT_POINT]=""
    # SSH Port (Usually 22)
    [PORT]=""
    # Path to SSH private key
    [PRIVATE_KEY]=""
    # Extra SSHFS options
    [SSH_OPTIONS]=""
    # Enable script debugging
    [DEBUG]=0
    # Enable colors
    [COLORS]=1
    # Ping timeout (sec) before mounting
    [PING_TIMEOUT]=3
    # Auto un-mount after N seconds (0 = disable)
    [MOUNT_TIMEOUT]=0
    # Permissions apply to Local mount point
    [LOCAL_MOUNT_DIR_PERMS]=755
)

### Unified logging logging function
# Supported log types: info | warn | error | debug
function LOG() {
    local type_="$1"
    shift
    local color
    case "$type_" in
        info)  color="${GREEN}" ;;
        warn)  color="${ORANGE}" ;;
        error) color="${RED}" ;;
        debug)
            [[ ${CONFIG[DEBUG]} -eq 1 || $ENABLE_DEBUG -eq 1 ]] || return
            color="${DEBUG_GRAY}"
            ;;
        *) return ;;  # Unknown type, bail silently
    esac
    printf "[%b%b%b]: %b\n" "${color}" "${type_}" "${NC}" "$*"
}

function Usage() {
    local RED='\033[0;31m'      # Red
    local GREEN='\033[0;32m'    # Green
    local YELLOW='\033[1;33m'   # Bold Yellow
    local CYAN='\033[0;36m'     # Cyan
    local BOLD='\033[1m'        # Bold
    local NC='\033[0m'          # No Color

    printf "%b\n" \
        "${CYAN}${BOLD}MountSSHFS_filesystem - Portable SSHFS mount utility with network checks and auto unmount${NC}" \
        "" \
        "${BOLD}Usage:${NC}" \
        "  ${YELLOW}$(basename "$0") [options]${NC}" \
        "" \
        "${BOLD}Options:${NC}" \
        "  ${GREEN}-e${NC}, ${GREEN}--edit${NC}           Edit the SSHFS configuration file" \
        "  ${GREEN}-es${NC}, ${GREEN}--edit-source${NC}   Edit this file itself" \
        "  ${GREEN}-s${NC}, ${GREEN}--show${NC}           Show the currently loaded configuration" \
        "  ${GREEN}-sp${NC}, ${GREEN}--show-profile${NC}  Show specific profile and load it" \
        "  ${GREEN}-l${NC}, ${GREEN}--list-profiles${NC}  List the ${PROFILE_DIRECTORY} in tree format" \
        "  ${GREEN}-p${NC}, ${GREEN}--profile${NC}        Specify the profile name" \
        "  ${GREEN}-c${NC}, ${GREEN}--config${NC}         Specify the full path to config file" \
        "  ${GREEN}-cat${NC}, ${GREEN}--cat${NC}          Concatinate the config file" \
        "  ${GREEN}-u${NC}, ${GREEN}--umount${NC}         Unmount the SSHFS mount point" \
        "  ${GREEN}-m${NC}, ${GREEN}--mount${NC}          Mount the SSHFS mount point" \
        "  ${GREEN}-su${NC}, ${GREEN}--sudo${NC}          Use sudo for mount/unmount operations" \
        "  ${GREEN}-f${NC}, ${GREEN}--force${NC}          Do not confirm" \
        "  ${GREEN}-d${NC}, ${GREEN}--debug${NC}          Enable debug output" \
        "  ${GREEN}-nc${NC}, ${GREEN}--no-color${NC}      Disable color output" \
        "  ${GREEN}-h${NC}, ${GREEN}--help${NC}           Show this help message and exit" \
        "" \
        "${BOLD}Description:${NC}" \
        "  This script mounts remote filesystems over SSHFS with automatic network checks," \
        "  optional auto-unmount after a timeout, and supports editing configuration interactively." \
        "" \
        "${BOLD}Example:${NC}" \
        "  ${YELLOW}$(basename "$0") --edit${NC}" \
        "  Opens the profile in your editor for modification." \
        "" \
        "  ${YELLOW}$(basename "$0") --umount${NC}" \
        "  Mounts the SSHFS filesystem from profile." \
        "" \
        "  ${YELLOW}$(basename "$0") --umount${NC}" \
        "  Unmounts the mounted SSHFS filesystem from profile." \
        "" \
        "  ${YELLOW}$(basename "$0")${NC}" \
        "  If default profile exists mount from it, otherwise ask user to enter details." \
        ""
}

# Immediately exit when FATAL is called
function FATAL() {
    local msg="$1"
    local exit_code=$2
    [[ $exit_code -gt 0 ]] && {
        printf "\n%s\n%s\n" "$2 errors encountered" "$msg"
        exit "$exit_code"
    }
}

# Installs a package using the system's package manager
# Detects pacman, apt, dnf, or yum
function InstallTool() {
    if command -v pacman &> /dev/null; then
        sudo pacman -Sy --noconfirm "$1"
    elif command -v apt &> /dev/null ; then
        sudo apt update && sudo apt install -y "$1"
    elif command -v dnf &> /dev/null; then
        sudo dnf install -y "$1"
    elif command -v yum &> /dev/null; then
        sudo yum install -y "$1"
    fi
}

function CheckDependencies() {
    local -a deps=( sshfs ssh fuser tree fusermount findmnt lsof )
    local -a not_found=()
    local yesno=""
    for cmd in "${deps[@]}"; do
        command -v "$cmd" &> /dev/null || not_found+=("$cmd")
    done

    if [[ ${#not_found[@]} -gt 0 ]]; then
        LOG error "${not_found[*]} Not found; Install it first."
        printf "%s: " "Install ${not_found[*]} (y|n)"; read -r yesno
        [[ $yesno =~ ^(y|Y)$ ]] && InstallTool "${not_found[@]}" || FATAL "Exiting..." 1
    fi
}

# Auto-detects and sets a TUI text editor (Neovim > Vim > Nano) for config editing
# Falls back to installing vim if none found
function SetTextEditor() {
    local -a Editors=( nvim vim micro nano )
    local found=""
    for editor in "${Editors[@]}"; do
        if command -v nvim 1> /dev/null 2>&1; then
            found="$editor"
            break
        fi
    done
    if [[ -z $found ]]; then
        LOG warn "NO text editor found on your system"
        LOG info "Installing vim"
        InstallTool "vim"
    fi
    EDITOR=${found:-"vim"}
}

function SetColors() {
    # ANSI escape sequences for RGB-based color output (eye candy logging in terminal)
    local colors="$1"
    LOG debug "Setting up colors"
    if [[ $colors -eq 0 || ${CONFIG[COLORS]} -eq 0 ]]; then
        RED="" GREEN="" BLUE="" DEBUG_GRAY="" LITTLE_BLUE="" YELLOW="" SKIN_COL="" GRAY="" ORANGE="" NC=""
        return 0
    fi
    RED="\033[38;2;255;75;75m"
    GREEN="\033[38;2;138;230;81m"
    BLUE="\033[38;2;110;147;235m"
    DEBUG_GRAY="\033[38;2;200;200;200m"
    LITTLE_BLUE="\033[38;2;126;117;255m"
    YELLOW="\033[38;2;226;220;120m"
    SKIN_COL="\033[38;2;170;170;127m"
    GRAY="\033[38;2;125;125;125m"
    ORANGE="\033[38;2;255;170;10m"
    NC="\033[0m"
}

function TermuxUser() {
    ### Helping Messages for Termux user
    LOG info "The termux default user home directory '${LITTLE_BLUE}${CONFIG[LOCAL_MOUNT_POINT]}/data/data/com.termux/files/home${NC}'"
    LOG info "Phone's internal stroage filesystem '${LITTLE_BLUE}${CONFIG[LOCAL_MOUNT_POINT]}/storage/emulated/0/${NC}'"
}

# Displays an ASCII-style script banner
function DrawBanner() {
  printf "%b\n" "${YELLOW}"
  printf "%s\n" "=========================="
  printf "%s\n" "║ SSHFS Mount Utility    ║"
  printf "%s\n" "=========================="
  printf "%b\n" "${NC}"
}

# Nicely formats and prints current loaded config to stdout
# Triggered by --show or DEBUG=1
function ShowConfigFile() {
    local show_config="$1"
    local -a LogVar=("printf" "# ${GRAY}%b${NC}\n# ${ORANGE}%-40b${NC} = %b\n\n")
    local -a PrettyLog=("printf" "%b\n")

    if [[ ${CONFIG[DEBUG]} -eq 1 || $show_config -eq 1 ]]; then
        "${PrettyLog[@]}" \
        "#================#" \
        "# Current Config #" \
        "#=============#=============================================================#"
        "${LogVar[@]}" \
        "### SSH Username on the remote device" \
        "USER" "\"${CONFIG[USER]}\"" \
        "### Ip address or FQDN (Fully Qualified Domain Name) of the remote" \
        "HOST" "\"${CONFIG[HOST]}\"" \
        "### Remote path to mount" \
        "REMOTE_MOUNT_POINT" "\"${CONFIG[REMOTE_MOUNT_POINT]}\"" \
        "### Local directory or mount the remote path to" \
        "DESTINATION" "\"${CONFIG[LOCAL_MOUNT_POINT]}\"" \
        "### Private key for SSH authentication" \
        "PRIVATE_KEY" "\"${CONFIG[PRIVATE_KEY]}\"" \
        "### Additional SSH options (e.g., -oreconnect)" \
        "SSH_OPTIONS" "\"${CONFIG[SSH_OPTIONS]}"\" \
        "### SSH Port to use for connection" \
        "PORT" "${CONFIG[PORT]}" \
        "### Enable bash script debugging (yes or no)" \
        "DEBUG" "${CONFIG[DEBUG]}" \
        "### Timeout in seconds to wait for the remote host to respond (Network check)" \
        "PING_TIMEOUT" "${BLUE}${CONFIG[PING_TIMEOUT]}${NC}" \
        "### Automatically unmount after this many seconds (0 to disable)" \
        "MOUNT_TIMEOUT" "${BLUE}${CONFIG[MOUNT_TIMEOUT]}${NC}" \
        "### Set permission mode (e.g., 755) for the mount directory after mounting" \
        "LOCAL_MOUNT_DIR_PERMS" "${BLUE}${CONFIG[LOCAL_MOUNT_DIR_PERMS]}${NC}"
        "${PrettyLog[@]}" \
        "#===========================================================================#" \
        ""
    fi
}

# Writes CONFIG associative array values into a temporary bash-style config file
# Used for persistence across script runs
function WriteTo() {
    local file_name="$1"
    local force=$2

    if [[ $force -eq 0 ]]; then
        printf "'%b' does not exist. Create one (y|n): " "${file_name} "
        read -r key
        [[ "${key}" =~ ^(y|Y|yes|Yes)$ ]] || return 1
    fi

cat > "${file_name}" << EOF
#!/usr/bin/env bash

### Configuration File for SSHFS Mounting

### SSH Username on the remote device
USER="${CONFIG[USER]:-"root"}"

### Ip address or FQDN (Fully Qualified Domain Name) of the remote
HOST="${CONFIG[HOST]}"

### SSH Port to use for connection
PORT=${CONFIG[PORT]:-22}

### Remote path to mount
REMOTE_MOUNT_POINT="${CONFIG[REMOTE_MOUNT_POINT]:-"/"}"

### Local directory or mount the remote path to
LOCAL_MOUNT_POINT="${CONFIG[LOCAL_MOUNT_POINT]:-"/tmp/sshfsMountDef"}"

### Private key for SSH authentication
PRIVATE_KEY="${CONFIG[PRIVATE_KEY]}"

### Additional SSH options (e.g., -oreconnect)
SSH_OPTIONS="${CONFIG[SSH_OPTIONS]}"

### Enable bash script debugging (yes or no)
DEBUG=${CONFIG[DEBUG]}

### Enable colors
COLORS=1

### Timeout in seconds to wait for the remote host to respond (Network check)
PING_TIMEOUT=${CONFIG[PING_TIMEOUT]}

### Automatically unmount after this many seconds (0 to disable)
MOUNT_TIMEOUT=${CONFIG[MOUNT_TIMEOUT]}

### Set permission mode (e.g., 755) for the mount directory before mounting
LOCAL_MOUNT_DIR_PERMS=${CONFIG[LOCAL_MOUNT_DIR_PERMS]}

# vim:filetype=bash

EOF
    LOG info "New Config file created: ${LITTLE_BLUE}${file_name}${NC}"
}

function LoadConfigFile() {
    local profile="$1"
    local show_config="$2"
    LOG debug "source ${profile}"
    source "${profile}" || FATAL "Exiting..." 1
    local exit_=0

    local -a config_vars=(
        USER HOST PORT PRIVATE_KEY
        REMOTE_MOUNT_POINT LOCAL_MOUNT_POINT
        PRIVATE_KEY SSH_OPTIONS DEBUG COLORS
        PING_TIMEOUT MOUNT_TIMEOUT LOCAL_MOUNT_DIR_PERMS
    )
    IFS=$' '
    for key in "${config_vars[@]}"; do
        LOG debug "CONFIG[$key]=${!key}"
        CONFIG[$key]="${!key}"
        [[ -n "${CONFIG[$key]}" ]] || LOG debug "Empty variable CONFIG[$key]='${CONFIG[$key]}'"
        unset "$key"
    done
    [[ -z "${CONFIG[USER]}" ]] && {
        CONFIG[USER]="root"
        LOG error "No SSH username given in the config. Assuming its root now."
    }
    [[ -z "${CONFIG[HOST]}" ]] && {
        LOG error "No SSH hostname given in the config."
        exit_=$((exit_ + 1))
    }
    [[ -z "${CONFIG[REMOTE_MOUNT_POINT]}" ]] && {
        CONFIG[REMOTE_MOUNT_POINT]="/"
        LOG error "No remote mount point given in the config. Assuming its ${LITTLE_BLUE}/${NC}"
    }
    [[ -z "${CONFIG[LOCAL_MOUNT_POINT]}" ]] && {
        CONFIG[LOCAL_MOUNT_POINT]="/tmp/_sshfs_default_mount"
        LOG error "No local mount point given in the config. Assuming its ${LITTLE_BLUE}/tmp/_sshfs_default_mount${NC}"
    }

    ShowConfigFile "$show_config"
    FATAL "Exiting ..." $exit_
}

# Prompts user interactively to fill in CONFIG values
# Uses defaults when input is empty
function GetConfig() {
    # Inner function to prompt user, with default & message
    local guess=0

    get_useInput() {
        declare -n ref=$1       # name reference to the variable to fill
        local prompt=$2
        local default=$3
        local default_msg="$4"

        printf "%b%s%b" "${LITTLE_BLUE}" "$prompt" "${NC}"
        [[ -n $default ]] && printf " [%s]" "$default"
        printf ": "

        read -r input

        if [[ -z "$input" && -n "$default" ]]; then
            ref="$default"
            [[ -n "${default_msg}" ]] && echo -e "${default_msg}"
        else
            ref="$input"
        fi
    }

    get_useInput CONFIG[USER] "User" "root" "Assuming you are root."

    get_useInput CONFIG[HOST] "Host (IP or FQDN)" "" ""
    if [[ -z ${CONFIG[HOST]} ]]; then
        echo "Host is required, exiting."
        return 1
    fi

    [[ "${CONFIG[USER]}" == u0_a* ]] && guess=8022 || guess=22
    get_useInput CONFIG[PORT] "Port" "${guess}" "Assuming port ${guess}"
    if [[ -z ${CONFIG[PORT]} ]]; then
        echo "Port is required, exiting."
        return 1
    fi
    get_useInput CONFIG[REMOTE_MOUNT_POINT] "Remote mount point" "/" "Default ${BLUE}/${NC}"
    get_useInput CONFIG[LOCAL_MOUNT_POINT] "Local mount point" "/tmp/_sshfs_default_mount" "default '${BLUE}/tmp/_sshfs_default_mount${NC}'"
    get_useInput CONFIG[MOUNT_TIMEOUT] "Mount timeout (seconds)" "0" "Default 0"
    get_useInput CONFIG[SSH_OPTIONS] "SSH options" "" ""
    get_useInput CONFIG[PRIVATE_KEY] "Private key" "" ""

    # You can optionally unset get_useInput here if you want:
    unset -f get_useInput
}

# Opens config file using $EDITOR
# If config file doesn’t exist or is empty, creates it with defaults
function EditConfig() {
    SetTextEditor # Set the terminal text editor
    local profile="$1"
    local profile_="$( sed "s|/home/$(getent passwd | grep $UID | cut -d':' -f1)/|${LITTLE_BLUE//\\/\\\\}\${HOME}${NC//\\/\\\\}/|g" <(printf "%s\n" "${profile}") )"
    local force_profile_creation="$2"
    if [[ ! -s "${profile}" ]]; then
        WriteTo "${profile}" "$force_profile_creation"
    fi

    if [[ -n "${profile}" ]]; then
        LOG info "Editing ${profile_}"
        ${EDITOR:-"vim"} "${profile}"
    else
        LOG error "${ORANGE}profile${NC} not given"
        FATAL "Exiting..." 1
    fi
}

# Checks mount point, if exists mount exists attempt to unmount
function AttemptUnMount() {
    local -r mount="$1"

    removeDir() {
        if rmdir "${mount}" &> /dev/null; then
            LOG info "Cleaned: ${BLUE}${mount}${NC}"
        else
            LOG warn "Failed to clean: ${BLUE}${mount}${NC}. It has some leftovers"
        fi
    }

    # If it's a mount point
    if mountpoint -q "${mount}"; then
        LOG debug "Attempting to unmount: ${mount}"
    else
        LOG debug "Not a mount point: ${mount}"
        unset -f removeDir
        return 0
    fi

    LOG debug "Using lazy unmount"
    # Clean lazy unmount
    if timeout 2 fusermount -uz "${mount}" &> /dev/null; then
        LOG info "Successfully lazy unmount via fusermount: ${BLUE}${mount}${NC}"
        removeDir
        unset -f removeDir
        return 0
    else
        LOG error "Mount failed"
        LOG debug "Attempting lazy umount"
        sudo umount -l "${mount}" &> /dev/null || {
            LOG warn "Mount still stuck, likely a zombie"
            unset -f removeDir
            return 1
        }
        removeDir
        unset -f removeDir
        return 0
    fi

    LOG warn "fusermount -uz '${BLUE}${mount}${NC}' failed. Trying fallback methods"

    # Check if anything holding the mount point
    if command -v "lsof" &> /dev/null; then
        LOG info "files still open:"
        lsof +D "${mount}"
    elif command -v "fuser" &> /dev/null; then
        LOG info "Open files:"
        fuser -vm "${mount}"
    fi

    # SSHFS tied to this mount
    if timeout 2 findmnt -n -T "${mount}" | grep -q "${mount}"; then
        LOG warn "${BLUE}${mount}${NC} is still mounted"
    fi
    # Try lazy unmount again
    if timeout 2 fusermount -uz "${mount}" &> /dev/null; then
        LOG info "Successfully unmount: ${BLUE}${mount}${NC}"
        removeDir
        unset -f removeDir
        return 0
    fi
    # Final check in /proc/mounts
    if grep -q "${mount}" /proc/mounts; then
        LOG warn "Mount still listed in /proc/mounts — might be a zombie or stale mount"
        LOG info "Final attempt with lazy unmount"
        if sudo umount -l "${mount}" &>/dev/null; then
            removeDir
            unset -f removeDir
            return 0
        else
            unset -f removeDir
            return 1
        fi
    fi
}

function AttemptMount() {
    local -a cmd=("$@")
    for i in {1..3}; do
        [[ $i -ge 2 ]] && LOG info "attemting mount $i"
        LOG debug "Running: sshfs ${cmd[*]}"
        sshfs "${cmd[@]}" && return 0
        sleep $((i*2))
    done
    return 1
}

function HostReachable() {
    LOG debug "ping -c 1 -W ${CONFIG[PING_TIMEOUT]} ${CONFIG[HOST]} &> /dev/null"
    if ! ping -c 1 -W "${CONFIG[PING_TIMEOUT]}" "${CONFIG[HOST]}" &> /dev/null; then
        LOG error "'${LITTLE_BLUE}${CONFIG[HOST]}${NC}' Not reachable, check the connection."
        return 1
    fi
}

function CheckMountPoint() {
    local mountPoint="$1"
    if [[ -z "${mountPoint}" ]]; then
        LOG warn "mount point variable is empty"
        return 1
    fi
    if command -v findmnt &> /dev/null; then
        [[ $(findmnt -n -T "${mountPoint}" -o FSTYPE) == fuse* ]] && return 0 || return 1
    else
        grep -qF "${mountPoint}" /proc/mounts | grep -q fuse && return 0 || return 1
    fi
}

function CreateLocalMount() {
    local dir="$1"; shift
    local perms=$1; shift
    local -a sudo=("$@")
    LOG debug "${sudo[*]} mkdir -p ${dir} &> /dev/null"
    "${sudo[@]}" mkdir -p "${dir}" &> /dev/null || {
        LOG error "Cannot create '${LITTLE_BLUE}${dir}${NC}'"
        FATAL "Exiting..." 1
    }
    LOG debug "${sudo[*]} chmod ${perms} ${dir}"
    "${sudo[@]}" chmod "${perms}" "${dir}" || {
        LOG error "Cannot change permissions on '${LITTLE_BLUE}${dir}${NC}'"
    }
}

function MountSSHFS_() {
    local -a sshfs_cmd=("$@")

    if CheckMountPoint "${CONFIG[LOCAL_MOUNT_POINT]}"; then
        LOG info "${BLUE}${CONFIG[LOCAL_MOUNT_POINT]}${NC} is already mounted"
        return 0
    fi
    # Create local mount point
    LOG debug "If destination dir '${CONFIG[LOCAL_MOUNT_POINT]}' does not exist create it"
    if [[ ! -d "${CONFIG[LOCAL_MOUNT_POINT]}" ]]; then
        CreateLocalMount "${CONFIG[LOCAL_MOUNT_POINT]}" ${CONFIG[LOCAL_MOUNT_DIR_PERMS]} "${sudo[@]}"
    fi

    # Mount the remote or local device file system as a fuse.sshfs device using OpenSSH protocol
    if AttemptMount "${sshfs_cmd[@]}"; then
        echo && LOG info "Mounted $(mount | grep "${CONFIG[LOCAL_MOUNT_POINT]}")" | grep --color=always -E "${CONFIG[USER]}|${CONFIG[HOST]}"
        [[ ${CONFIG[MOUNT_TIMEOUT]} -gt 0 ]] && {
            LOG debug "(sleep ${CONFIG[MOUNT_TIMEOUT]} && ${sudo[*]} timeout --signal KILL 4 fusermount -u ${CONFIG[LOCAL_MOUNT_POINT]}) &"
            (sleep ${CONFIG[MOUNT_TIMEOUT]} && "${sudo[@]}" timeout --signal KILL 4 fusermount -u "${CONFIG[LOCAL_MOUNT_POINT]}") &
        }
        [[ ${CONFIG[USER]} == u0_a* ]] && TermuxUser
    else
        LOG error \
            "Failed to mount SSHFS remote:\
     ${SKIN_COL}${CONFIG[USER]}${NC}@${ORANGE}${CONFIG[HOST]}${NC}:${LITTLE_BLUE}${CONFIG[REMOTE_MOUNT_POINT]}${NC}\
     ${LITTLE_BLUE}${CONFIG[LOCAL_MOUNT_POINT]}${NC} on Port ${CONFIG[PORT]}"

        LOG debug "Call AttemptUnMount()"
        if AttemptUnMount "${CONFIG[LOCAL_MOUNT_POINT]}"; then
            LOG info "Unmounted: ${BLUE}${CONFIG[LOCAL_MOUNT_POINT]}${NC}"
        else
            LOG warn "Failed to Unmount ${BLUE}${CONFIG[LOCAL_MOUNT_POINT]}${NC}"
            FATAL "Exiting..." 1
        fi
    fi
}

### Parses script arguments like --edit, --show, --sudo, --unmount, etc.
# Sets flags for conditional execution later
function main() {
    CheckDependencies

    local -a ARGS_ARR=("$@")
    local -a sshfs_cmd=()
    local -a sudo=()

    # Flags
    local mount=0 unmount=0 ssh_only_=0
    local ls_config_dir=0 edit_config=0 show_config=0 cat_config=0
    local colors=1 force=0
    local profile_showed=0

    # This is default profile if --profile is not passed
    local config_profile="/tmp/.sshfsMountScriptConf"
    local profile_dir=""
    local requested_profile=""
    local show_profile=""
    profile_dir="$(realpath $(eval echo "${PROFILE_DIRECTORY}"))"

    # Helper function for debug logging
    log_debug() {
        local msg="$1"
        [[ $ENABLE_DEBUG -eq 1 ]] && LOG debug "$msg"
    }

    for (( i = 0; i < ${#ARGS_ARR[@]}; i++ )); do
        arg="${ARGS_ARR[$i]}"
        next_arg="${ARGS_ARR[$((i+1))]}"

        case "$arg" in
            -e|e|--e|--edit|-edit|edit)
                edit_config=1
                log_debug "edit_config=1"
                ;;

            -d|--d|--debug|-debug|debug)
                CONFIG[DEBUG]=1
                ENABLE_DEBUG=1
                log_debug "Debug mode enabled"
                ;;

            -p|p|--p|--prof|prof|--profile|-profile|profile)
                requested_profile="$next_arg"
                ((i++))
                log_debug "Selected profile: $requested_profile"
                ;;

            -p=*|p=*|--p=*|--prof=*|prof=*|-prof=*|--profile=*|-profile=*|profile=*)
                requested_profile="${arg#*=}"
                log_debug "Selected profile: $requested_profile"
                ;;

            -c|--c|--conf|--config|-config)
                config_profile="$next_arg"
                ((i++))
                log_debug "Custom config: $config_profile"
                ;;

            -c=*|--c=*|--conf=*|-conf=*|--config=*|-config=*)
                config_profile="${arg#*=}"
                log_debug "Custom config: $config_profile"
                ;;

            -s|s|--show|-show|show)
                show_config=1
                log_debug "show_config=1"
                ;;

            -cat|--cat|cat)
                cat_config=1
                log_debug "cat_config=1"
                ;;

            -l|l|--l|-lp|--lp|-list|--list|--list-profiles|-list-profiles)
                ls_config_dir=1
                log_debug "ls_config_dir=1"
                ;;

            -sp|sp|--sp|--show-profile|-show-profile|show-profile)
                show_profile="${next_arg}"
                log_debug "show specific profile: ${show_profile}"
                ;;

            -sp=*|sp=*|--sp=*|--show-profile=*|show-profile=*|-show-profile=*|show-profile=*)
                show_profile="${arg#*=}"
                log_debug "show specific profile: ${show_profile}"
                ;;

            -f|--f|-force|--force|force)
                force=1
                log_debug "force=1"
                ;;

            -ssh|--ssh|ssh)
                ssh_only_=1
                ;;

            -su|su|--sudo|sudo)
                sudo=("sudo" " ")
                log_debug "sudo enabled"
                ;;

            -nc|--no-color|--nocolor)
                CONFIG[COLORS]=0
                colors=0
                log_debug "colors=0"
                ;;

            -m|m|--m|--mount|-mount|mount)
                mount=1
                log_debug "mount=1"
                ;;

            -u|u|--u|--umount|unmount)
                unmount=1
                log_debug "unmount=1"
                ;;

            -es|es|--es|--edit-me|-edit-me|--edit-source|edit-source)
                ${EDITOR} "$(realpath $0)"
                return 0
                ;;

            -h|h|-help|--help|help)
                Usage
                exit 0
                ;;

            *)
                LOG error "Invalid argument: $arg"
                FATAL "Exiting..." 1
                ;;
        esac
    done

    LOG debug "Call SetColors"
    SetColors $colors

    mkdir -p "${profile_dir}"
    if [[ $ls_config_dir -eq 1 ]]; then
        echo && LOG info "Available Profiles:\n"
        tree -C "${profile_dir}"
        return 0
    fi

    if [[ -f "${profile_dir}/${show_profile}" ]]; then
        show_profile="${profile_dir}/${show_profile}"
        config_profile="${show_profile}"
        LoadConfigFile "${config_profile}" "1"
    fi

    if [[ -n "${requested_profile}" ]]; then
        requested_profile="${profile_dir}/${requested_profile}"
        if [[ -s "${requested_profile}" ]]; then
            config_profile="${requested_profile}"
        else
            LOG debug "Call WriteTo()"
            WriteTo "${requested_profile}" "$force"
            config_profile="${requested_profile}"
        fi
    fi

    # Edit the config and exit
    if [[ $edit_config -eq 1 ]]; then
        EditConfig "${config_profile}" "$force"
        return 0
    fi

    # If a previously written config file exists, source it
    # Else, prompt user to provide config interactively and save the config
    if [[ ! -s "${config_profile}" || $# -eq 0 ]]; then
        LOG debug "Config doesn't exist; ask user to enter details"
        # Get config values
        LOG debug "Call GetConfig()"
        GetConfig || FATAL "Exiting..." 1
        # After getting values, write to config
        LOG debug "Call WriteTo()"
        WriteTo "${config_profile}" "$force"
    fi

    # Load the profile
    LOG debug "Call LoadConfigFile"
    LoadConfigFile "${config_profile}" "$show_config"
    [[ "$show_config" -eq 1 ]] && show_config=0
    if [[ "$cat_config" -eq 1 ]]; then
        echo && LOG info "Concatinating: $config_profile" && echo
        if command -v bat &> /dev/null; then
            bat --paging=never --color=always --decorations=never --language=bash "${config_profile}"
            return 0
        else
            cat "${config_profile}"
            return 0
        fi
    fi
    LOG debug "Call SetColors()"
    SetColors $colors

    # Handles forced unmounting if its already mounted or --unmount is used
    if  [[ $unmount -eq 1 ]] || CheckMountPoint "${CONFIG[LOCAL_MOUNT_POINT]}" ; then
        if ! AttemptUnMount "${CONFIG[LOCAL_MOUNT_POINT]}"; then
            LOG warn "Failed to Unmount ${BLUE}${CONFIG[LOCAL_MOUNT_POINT]}${NC}"
            FATAL "Exiting..." 1
        fi
    fi

    # Fill sshfs_cmd array with sshfs flags and parameters
    [[ -n ${CONFIG[PRIVATE_KEY]} ]] && [[ -r "${CONFIG[PRIVATE_KEY]}" ]] && {
        sshfs_cmd+=("-o" "IdentitiesOnly=yes" "-o" "IdentityFile=${CONFIG[PRIVATE_KEY]}")
    }
    [[ -n "${CONFIG[SSH_OPTIONS]}" ]] && sshfs_cmd+=("-o" "${CONFIG[SSH_OPTIONS]}")
    [[ -z ${CONFIG[PORT]} && "${CONFIG[USER]}" == u0_a* ]] && CONFIG[PORT]=8022
    [[ -z ${CONFIG[PORT]} ]] && CONFIG[PORT]=22
    [[ -n ${CONFIG[PORT]} ]] && sshfs_cmd+=("-o" "ssh_command=ssh -p ${CONFIG[PORT]}")
    sshfs_cmd+=("${CONFIG[USER]:="root"}@${CONFIG[HOST]}:${CONFIG[REMOTE_MOUNT_POINT]:="/"}")
    sshfs_cmd+=("${CONFIG[LOCAL_MOUNT_POINT]:="/tmp/DEFAULT_MOUNT"}")

    config_profile="$( sed "s|/home/$(getent passwd | grep $UID | cut -d':' -f1)/|${LITTLE_BLUE//\\/\\\\}\${HOME}${NC//\\/\\\\}/|g" <(printf "%s\n" "${config_profile}") )"


    if [[ $ssh_only_ -eq 1 && $mount -eq 1 ]]; then

        # Before mounting or SSH, check if remote is alive and listening
        HostReachable || FATAL "Exiting..." 1

        LOG debug "Call DrawBanner()"
        DrawBanner

        LOG info "Mount and SSH into remote"
        echo && LOG info "Mounting remote: '${CONFIG[HOST]}' from profile ${config_profile}"
        MountSSHFS_ "${sshfs_cmd[@]}"
        ### Log the final messages

        echo && LOG info "SSH into '${CONFIG[HOST]}' from profile ${config_profile}" && echo
        ssh -p "${CONFIG[PORT]}" "${CONFIG[USER]-"root"}@${CONFIG[HOST]}"

        LOG debug "Call ShowConfigFile()"
        ShowConfigFile $show_config
        return 0
    fi

    if [[ $ssh_only_ -eq 1 ]]; then
        # Before SSH, check if remote is alive and listening
        HostReachable || FATAL "Exiting..." 1

        echo && LOG info "SSH into '${CONFIG[HOST]}' from profile ${config_profile}" && echo
        LOG debug "Call DrawBanner()"
        DrawBanner
        ssh -p "${CONFIG[PORT]}" "${CONFIG[USER]-"root"}@${CONFIG[HOST]}"
        LOG debug "Call ShowConfigFile()"
        ShowConfigFile $show_config
        return 0
    fi

    ## Execute this block on --mount -m
    if [[ $mount -eq 1 ]]; then
        # Before mounting, check if remote is alive and listening
        HostReachable || FATAL "Exiting..." 1

        LOG debug "Call DrawBanner()"
        DrawBanner

        echo && LOG info "Mounting remote: '${CONFIG[HOST]}' from profile ${config_profile}"
        MountSSHFS_ "${sshfs_cmd[@]}"
        ### Log the final messages
        LOG debug "Call ShowConfigFile()"
        ShowConfigFile $show_config
        return 0
    fi
}

main "$@"

